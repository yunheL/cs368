<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<LINK rel="stylesheet" type="text/css" href="../example.css">
<title>Polynomial Example</title>
</head>

<body>
<h1>Polynomial Example</h1>
<p>Source files (for downloading):</p>
<ul>
<li><a href="Polynomial.h">Polynomial.h</a></li>
<li><a href="Polynomial.cpp">Polynomial.cpp</a></li>
<li><a href="testPolynomial.cpp">testPolynomial.cpp</a></li>
<li><a href="Makefile">Makefile</a></li>
</ul>

<hr>
<h2>Polynomial.h</h2>
<pre>#ifndef POLYNOMIAL_H
#define POLYNOMIAL_H
 
#include <iostream>
using namespace std;
 
class Polynomial {
 
    friend bool operator==(const Polynomial & lhs, const Polynomial & rhs);
 
    public:
 
        <i>// constructors</i>
        Polynomial();
        Polynomial(double coefficients[], int number);
        Polynomial(const Polynomial & rhs);
        explicit Polynomial(double const_term);
 
        <i>// destructor</i>
        ~Polynomial();
 
        <i>// named member functions</i>
        int degree() const { return size - 1; }
        void print(ostream & out = cout) const;
 
        <i>// assignment operators</i>
        Polynomial & operator= (const Polynomial & rhs);
        Polynomial & operator+= (const Polynomial & rhs);
        Polynomial & operator*= (double rhs);
 
 
    private:
        int size;       <i>// size of the coefs array ( = degree + 1)</i>
        double * coefs; <i>// coefs will be an array</i>
};
 
 
Polynomial operator+(const Polynomial & lhs, const Polynomial & rhs);
 
Polynomial operator*(const Polynomial & lhs, double rhs);
Polynomial operator*(double lhs, const Polynomial & rhs);
 
ostream & operator&lt;&lt;(ostream & out, const Polynomial & p);
 
#endif</pre>
<hr>

<h2>Constructors</h2>
<pre><i>// Constructor
// Creates a default polynomial p of the form p(x) = 0.0</i>
Polynomial::<b>Polynomial()</b> : size(1), coefs(new double[1]) { 
    coefs[0] = 0.0;
}
 
<i>// Constructor
// Given an array of coefficients C (and it's size N) creates a polynomial
// p(x) = C[N-1]x^(N-1) + ... + C[2]x^2 + C[1]x + C[0] </i>
Polynomial::<b>Polynomial(double coefficients[], int number)</b> : 
  size(number), coefs(new double[number]) {
    for (int i = 0; i < size; i++) {
        coefs[i] = coefficients[i];
    }
}
 
<i>// Constructor
// Given a constant term A, creates the polynomial p(x) = A</i>
Polynomial::<b>Polynomial(double const_term)</b> : size(1), coefs(new double[1]) {
    coefs[0] = const_term;
} 
</pre>
<hr>

<h2>The &quot;Big Three&quot;</h2>
<pre><i>// Copy constructor
// Creates a polynomial from the given polynomial</i>
Polynomial::<b>Polynomial(const Polynomial & rhs)</b> : 
  size(rhs.size), coefs(new double[rhs.size]) {
    for (int i = 0; i < size; i++) {
        coefs[i] = rhs.coefs[i];
    }
}
 
 
<i>// Destructor</i>
Polynomial::<b>~Polynomial()</b> {
    delete [] coefs;
}
 
 
<i>// Overload assignment =</i>
<b>Polynomial &</b> Polynomial::<b>operator=(const Polynomial & rhs)</b> {
    if (this == &rhs) {
        return *this;
    }
 
    else {
        delete [] coefs;
        coefs = new double[rhs.size];
        size = rhs.size;
        for (int i = 0; i < size; i++) {
            coefs[i] = rhs.coefs[i];
        }
    }
    return *this;
}
 
 
</pre>
<hr>

<h2>Overloaded operators (member functions)</h2>
<pre><i>// Overload assignment +=</i>
<b>Polynomial &</b> Polynomial::<b>operator+=(const Polynomial & rhs)</b> {
    int newSize = (rhs.size > size) ? rhs.size : size;
    double *newCoef = new double [newSize]; 

    for (int i = 0; i < newSize; i++) {
        newCoef[i] = 0;
    }
    for (int i = 0; i < rhs.size; i++) {
        newCoef[i] += rhs.coefs[i];
    }
    for (int i = 0; i < size; i++) {
        newCoef[i] += coefs[i];
    }
    delete [] coefs; 
    coefs = newCoef;
    size = newSize;
    return *this;
}
 
 <i>
// Overload assignment *= so it supports scalar multiplication</i>
<b>Polynomial &</b> Polynomial::<b>operator*=(double rhs)</b> {
    for (int i = 0; i < size; i++) {
        coefs[i] *= rhs;
    }
    return *this;
}
  
</pre>
<hr>

<h2>Overloaded operators (non-member functions)</h2>
<pre><i>// Overload +</i>
<b>Polynomial operator+(const Polynomial & lhs, const Polynomial & rhs)</b> {
    Polynomial answer(lhs);
    answer += rhs;
    return answer;
}
 
 
<i>// Overload * so it supports scalar multiplication.  Note that
// we overload it twice so we can do either:
//    polynomial * scalar
// or
//    scalar * polynomial</i>

<b>Polynomial operator*(const Polynomial & lhs, double rhs)</b> {
    Polynomial answer(lhs);
    answer *= rhs;
    return answer;
}
 
<b>Polynomial operator*(double lhs, const Polynomial & rhs)</b> {
    Polynomial answer(rhs);
    answer *= lhs;
    return answer;
}
</pre>
<hr>

<h2>Overloading I/O</h2>
<pre><i>// Prints the polynomial to the given ostream.  If no ostream is given,
// the polynomial is printed to cout</i>
<b>void</b> Polynomial::<b>print(ostream & out)</b> const {
    if (size == 0) {
        return;
    }
 
    for (int i = size - 1; i > 0; i--)
        out &lt;&lt; coefs[i] &lt;&lt; "x^" &lt;&lt; i &lt;&lt; " + ";
    out &lt;&lt; coefs[0];
}
 
 
<i>// Overload &lt;&lt; for output</i>
<b>ostream & operator&lt;&lt;(ostream & out, const Polynomial & p)</b> {
    p.print(out);
    return out;
}
 
 
</pre>
<hr>

<h2>Overloading relational operators</h2>
<pre><i>// Overload ==</i>
<b>bool operator==(const Polynomial & lhs, const Polynomial & rhs)</b> {
    if (lhs.size != rhs.size) {
        return false;
    }
 
    for (int i = 0; i < lhs.size; i++) {
        if (lhs.coefs[i] != rhs.coefs[i]) {
            return false;
        }
    }
    return true;
}
</pre>
</body></html>
